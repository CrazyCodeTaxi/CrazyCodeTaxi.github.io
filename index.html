<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="搞事必须第一">
<meta property="og:type" content="website">
<meta property="og:title" content="Taxi">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Taxi">
<meta property="og:description" content="搞事必须第一">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘志杰">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Taxi</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Taxi</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘志杰"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">刘志杰</p>
  <div class="site-description" itemprop="description">搞事必须第一</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/cocos-engine-dynamic-atlas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘志杰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taxi">
      <meta itemprop="description" content="搞事必须第一">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Taxi">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/02/cocos-engine-dynamic-atlas/" class="post-title-link" itemprop="url">CocosCreator-渲染篇 动态合图（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-02 10:49:42" itemprop="dateCreated datePublished" datetime="2022-04-02T10:49:42+08:00">2022-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-02 11:56:24" itemprop="dateModified" datetime="2023-06-02T11:56:24+08:00">2023-06-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>问：何为动态图集</p>
<p><strong>能在项目运行时动态地将贴图合并到一张大贴图中</strong>。</p>
<p>问：那这又能提升什么，</p>
<p><strong>降低 DrawCall 是提升游戏渲染效率一个非常直接有效的办法，两个 DrawCall 是否可以合并为一个 DrawCall 的其中一个重要因素就是这两个 DrawCall 是否使用了同一张贴图。</strong></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>若希望强制开启动态合图</strong>，请在代码中加入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">macro.<span class="property">CLEANUP_IMAGE_CACHE</span> = <span class="literal">false</span>;</span><br><span class="line">dynamicAtlasManager.<span class="property">enabled</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这些代码请写在项目脚本中的最外层，不要写在 <code>onLoad</code>&#x2F;<code>start</code> 等类函数中，才能确保在项目加载过程中即时生效。否则如果在部分贴图缓存已经释放的情况下才启用动态图集，可能会导致报错。</p>
<p><strong>若希望强制禁用动态合图</strong>，可以直接通过代码控制：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamicAtlasManager.<span class="property">enabled</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><strong>目前支持动态合图的渲染组件：Sprite、Label(BITMAP模式)。</strong></p>
<p><strong>通过代码了解，在使用上还有些限制：</strong></p>
<ul>
<li><p>在贴图的多个属性设置不同的设置会影响Cocos合批，并非只要插入了动态合图中就一定会合批这点需要注意，原因是Cocos的Sprite在处理不同设置可能采取不同的shader来渲染图片。</p>
</li>
<li><p>默认的动态合图最大数量为5张<a href="%E5%9C%A8cocos-engine%E4%B8%AD%E7%9A%84cocos2d/core/renderer/utils/dynamic-atlas/manager.js%E4%B8%AD%E7%9A%84_maxAtlasCount">^maxAtlasCount</a>，在达到最大上线后就不在自动合并图集了</p>
</li>
<li><p>如果游戏中只有一个场景，没有场景的切换那动态合图数量会随着图片的插入<a href="%E5%9C%A8cocos-engine%E4%B8%AD%E7%9A%84cocos2d/core/renderer/utils/dynamic-atlas/manager.js%E4%B8%AD%E7%9A%84insertSpriteFrame%E5%87%BD%E6%95%B0">^insertSpriteFrame</a>而增长，渲染效率可能会降低。</p>
</li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4 id="看看引擎中关于动态合图部分重要的源码"><a href="#看看引擎中关于动态合图部分重要的源码" class="headerlink" title="看看引擎中关于动态合图部分重要的源码"></a>看看引擎中关于动态合图部分重要的源码</h4><ul>
<li>atlas.js（cocos2d&#x2F;core&#x2F;renderer&#x2F;utils&#x2F;dynamic-atlas）</li>
<li>manager.js（cocos2d&#x2F;core&#x2F;renderer&#x2F;utils&#x2F;dynamic-atlas）</li>
<li>assembler-2d.js （cocos2d&#x2F;core&#x2F;renderer）</li>
</ul>
<h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>在<strong>assembler-2d</strong>中定义着<strong>packToDynamicAtlas</strong>函数，在插入合图后需要重新更新uv。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在纹理加载完成切纹理的设置的在编辑器中勾选了packable在能合图</span></span><br><span class="line"><span class="keyword">if</span> (!frame.<span class="property">_original</span> &amp;&amp; dynamicAtlasManager &amp;&amp; frame.<span class="property">_texture</span>.<span class="property">packable</span> &amp;&amp; frame.<span class="property">_texture</span>.<span class="property">loaded</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> packedFrame = dynamicAtlasManager.<span class="title function_">insertSpriteFrame</span>(frame);</span><br><span class="line">    <span class="keyword">if</span> (packedFrame) &#123;</span><br><span class="line">        frame.<span class="title function_">_setDynamicAtlasFrame</span>(packedFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> material = comp.<span class="property">_materials</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (!material) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (material.<span class="title function_">getProperty</span>(<span class="string">&#x27;texture&#x27;</span>) !== frame.<span class="property">_texture</span>.<span class="property">_texture</span>) &#123;</span><br><span class="line">    <span class="comment">// 在纹理被打包到动态图集，应该更新 uvs</span></span><br><span class="line">    comp.<span class="property">_vertsDirty</span> = <span class="literal">true</span>;</span><br><span class="line">    comp.<span class="title function_">_updateMaterial</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在来看看<strong>dynamicAtlasManager</strong>的<strong>insertSpriteFrame</strong>函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable constant_">CC_EDITOR</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 在开启动态合图情况，合图数超过最大数后就结束自动合图了</span></span><br><span class="line"><span class="keyword">if</span> (!_enabled || _atlasIndex === _maxAtlasCount ||</span><br><span class="line">    !spriteFrame || spriteFrame.<span class="property">_original</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!spriteFrame.<span class="property">_texture</span>.<span class="property">packable</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> atlas = _atlases[_atlasIndex];</span><br><span class="line"><span class="keyword">if</span> (!atlas) &#123;</span><br><span class="line">    atlas = <span class="title function_">newAtlas</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> frame = atlas.<span class="title function_">insertSpriteFrame</span>(spriteFrame);</span><br><span class="line"><span class="keyword">if</span> (!frame &amp;&amp; _atlasIndex !== _maxAtlasCount) &#123;</span><br><span class="line">    atlas = <span class="title function_">newAtlas</span>();</span><br><span class="line">    <span class="keyword">return</span> atlas.<span class="title function_">insertSpriteFrame</span>(spriteFrame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> frame;</span><br></pre></td></tr></table></figure>

<p>最后是Atlas的insertSpriteFrame</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = spriteFrame.<span class="property">_rect</span>,</span><br><span class="line">    texture = spriteFrame.<span class="property">_texture</span>,</span><br><span class="line">    info = <span class="variable language_">this</span>.<span class="property">_innerTextureInfos</span>[texture.<span class="property">_id</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sx = rect.<span class="property">x</span>, sy = rect.<span class="property">y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> frame = &#123;</span><br><span class="line">    <span class="attr">x</span>: sx,</span><br><span class="line">    <span class="attr">y</span>: sy,</span><br><span class="line">    <span class="attr">texture</span>: <span class="variable language_">this</span>.<span class="property">_texture</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_innerSpriteFrames</span>.<span class="title function_">push</span>(spriteFrame);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> frame;</span><br></pre></td></tr></table></figure>

<p>这就是引擎中自动合图的关键部分了</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>在下一篇文章中在详细介绍</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/22/gameloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘志杰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Taxi">
      <meta itemprop="description" content="搞事必须第一">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Taxi">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/22/gameloop/" class="post-title-link" itemprop="url">游戏循环</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-22 09:43:54" itemprop="dateCreated datePublished" datetime="2022-03-22T09:43:54+08:00">2022-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-02 11:56:16" itemprop="dateModified" datetime="2023-06-02T11:56:16+08:00">2023-06-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>如名一样，游戏循环往往是一个带有跳出控制的<strong>“死循环”</strong>，尽可能快的接受输入，处理随时间改变的状态和AI等，播放声音，渲染图形。游戏循环就是游戏中的可一直重复切带有顺序依赖（贯穿整个游戏生命周期）的行动集合。</p>
<p>就像这个很早的文字交互游戏：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;你回家的路上遇到了一只毒甲虫，它朝你涂了一口毒液。</span><br><span class="line">&gt;A:战斗，B:逃跑</span><br><span class="line">&gt;A</span><br><span class="line">&gt;战斗开始。。。。</span><br></pre></td></tr></table></figure>

<p>获取玩家输入，然后更新游戏状态，最后再刷新界面的文字显示。它等待你的输入，然后进行响应。 你再输入，这样一唱一和，就像相声一样。 当轮到你时，它停在那里啥也不做。像这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = <span class="title function_">waitForInput</span>(); <span class="comment">// 等待玩家输入并阻塞线程</span></span><br><span class="line">	<span class="title function_">handleEvent</span>(e);</span><br><span class="line">	<span class="title function_">render</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于近些年的游戏循环的第一个关键部分：<strong><em>它处理用户输入，但是不等待它</em>。</strong>循环会持续运行：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="title function_">processInput</span>(); <span class="comment">// 不阻塞线程，即使没有输入也继续。</span></span><br><span class="line">	<span class="title function_">update</span>();</span><br><span class="line">	<span class="title function_">render</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processInput()</code>处理上次调用到现在的任何输入。 然后<code>update()</code>让游戏模拟一步。 运行AI和物理（通常是这种顺序）。 最终，<code>render()</code>绘制游戏，这样玩家可以看到发生了什么。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>我们是想一下这个<strong>“死循环”</strong>，如果没有这个循环没有因为输入而堵塞，这样就带来了一个明显的问题：<em>它会运行的有多快？</em>，循环中每一次轮回都会推进游戏状态向前走一小步。从游戏视角看，就像手表的指针滴答步进了一下。</p>
<p>于此同时，现实中的手表也不紧不慢滴答运作着。如果我们用现实中的时间来观测游戏中运行的速度，就引出游戏的<strong>“帧率”</strong>（FPS）。如果循环运行速度越快，那么FPS就意味着更高，游戏更流畅。反正，着FPS慢，切画面不流畅。</p>
<p>像上面的代码所示的循环，它能跑多快跑多快，影响到运行速度的有两个因素。首先是在每一帧中做多少工作。例如成千上万的游戏对象，复杂的物理和大量的图形，都会让CPU和GPU陷入忙碌中，导致每一帧消耗一个不小的时间来完成工作。第二个原因就是受限于底层平台的运行速度，更快更强的平台都会影响它在一帧中可以做多少东西。</p>
<h3 id="这就是我们这个“死循环”的另一个关键任务：不管潜在的硬件条件，以固定速度运行游戏。"><a href="#这就是我们这个“死循环”的另一个关键任务：不管潜在的硬件条件，以固定速度运行游戏。" class="headerlink" title="这就是我们这个“死循环”的另一个关键任务：不管潜在的硬件条件，以固定速度运行游戏。"></a>这就是我们这个“死循环”的另一个关键任务：<em>不管潜在的硬件条件，以固定速度运行游戏。</em></h3><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="打个盹"><a href="#打个盹" class="headerlink" title="打个盹"></a><strong>打个盹</strong></h3><p>我们看看增加一个简单的小修正如何。 假设你想要你的游戏以60FPS运行。这样每帧大约16毫秒。 只要你用少于这个的时长进行游戏所有的处理和渲染，就可以以稳定的帧率运行。 你需要做的就是处理这一帧然后<em>等待</em>，直到处理下一帧的时候，就像这样：</p>
<img src="/2022/03/22/gameloop/game-loop-simple.png" class="" title="一个简单的游戏循环流程图。处理输入 → 更新游戏 → 渲染 → 等待，然后从头开始。">

<p>代码看上去像这样：</p>
<p>MS_PER_FRAME &#x3D; <em>1000 毫秒 &#x2F; 帧率 &#x3D; 毫秒每帧</em>.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">    <span class="title function_">processInput</span>();</span><br><span class="line">    <span class="title function_">update</span>();</span><br><span class="line">    <span class="title function_">render</span>();</span><br><span class="line">    <span class="title function_">sleep</span>(start + <span class="variable constant_">MS_PER_FRAME</span> - <span class="title function_">getCurrentTime</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实际上来说已经可用了，因为如果一台电脑非常慢的话，它也只会按照它能力的最大刷新率来更新游戏（因为你不能sleep一个负值）。但是，虽然能用，这个方法还是不够好。如果一台电脑很厉害，我们应该让其拥有能力去显示更棒的画面、更流畅的动画，而不是单纯地给它定死在一个值上面，于是我们就有了下面的想法。</p>
<h3 id="不固定的步长"><a href="#不固定的步长" class="headerlink" title="不固定的步长"></a>不固定的步长</h3><p>让我们尝试一些更加复杂的东西。我们拥有的问题基本上是：</p>
<ol>
<li>每次更新将游戏时间推动一个固定量。</li>
<li>这消耗一定量的<em>真实</em>时间来处理它。</li>
</ol>
<p>如果第二步消耗的时间超过第一步，游戏就变慢了。 如果它需要超过16ms来推动游戏时间16ms，那它永远也跟不上。 但是如果一步中推动游戏时间<em>超过</em>16ms，那我们可以减少更新频率，就可以跟得上了。</p>
<p>接着的思路是基于上帧到现在有多少<em>真实</em>时间流逝来选择前进的时间。 这一帧花费的时间越长，游戏的间隔越大。 它总能跟上真实时间，因为它走的步子越来越大。 有人称之为<em>变化的</em>或者<em>流动的</em>时间间隔。它看上去像是：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">    <span class="keyword">let</span> elapsed = current - lastTime;</span><br><span class="line">    <span class="title function_">processInput</span>();</span><br><span class="line">    <span class="title function_">update</span>(elapsed);</span><br><span class="line">    <span class="title function_">render</span>();</span><br><span class="line">    lastTime = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一帧，我们计算上次游戏更新到现在有多少<em>真实</em>时间过去了（即变量<code>elapsed</code>）。 当我们更新游戏状态时将其传入。 然后游戏引擎让游戏世界推进一定的时间量。</p>
<p>假设有一颗子弹跨过屏幕。 使用固定的时间间隔，在每一帧中，你根据它的速度移动它。 使用变化的时间间隔，你<em>根据过去的时间拉伸速度</em>。 随着时间间隔增加，子弹在每帧间移动得更远。 无论是二十个快的小间隔还是四个慢的大间隔，子弹在<em>真实</em>时间里移动<em>同样</em>多的距离。 这看上去成功了：</p>
<ul>
<li>游戏在不同的硬件上以固定的速度运行。</li>
<li>使用高端机器的玩家获得了更流畅的游戏体验。</li>
</ul>
<p>但悲剧的是，这里有一个严重的问题： 游戏不再是确定的了，也不再稳定。 这是我们给自己挖的一个坑：</p>
<p>“确定的”代表每次你运行程序，如果给了它同样的输入，就获得同样的输出。 可以想得到，在确定的程序中追踪漏洞更容易——一旦找到造成漏洞的输入，每次你都能重现之。</p>
<p>计算机本身是确定的；它们机械地执行程序。 在纷乱的真实世界搀合进来，非确定性就出现了。 例如，网络，系统时钟，线程调度都依赖于超出程序控制的外部世界。</p>
<p>假设我们有个双人联网游戏，Fred的游戏机是台性能猛兽，而George正在使用他祖母的老爷机。 前面提到的子弹在他们的屏幕上飞行。 在Fred的机器上，游戏跑得超级快，每个时间间隔都很小。 比如，我们塞了50帧在子弹穿过屏幕的那一秒。 可怜的George的机器只能塞进大约5帧。</p>
<p>这就意味着在Fred的机器上，物理引擎每秒更新50次位置，但是George的只更新5次。 大多数游戏使用浮点数，它们有<em>舍入误差</em>。 每次你将两个浮点数加在一起，获得的结果就会有点偏差。 Fred的机器做了10倍的操作，所以他的误差要比George的更大。 <em>同样</em> 的子弹最终在他们的机器上到了<em>不同的位置</em>。</p>
<p>这是使用变化时间可引起的问题之一，还有更多问题呢。 为了实时运行，游戏物理引擎做的是实际机制法则的近似。 为了避免飞天遁地，物理引擎添加了阻尼。 这个阻尼运算被小心地安排成以固定的时间间隔运行。 改变了它，物理就不再稳定。</p>
<p>“飞天遁地”在这里使用的是它的字面意思。当物理引擎卡住，对象获得了完全错误的速度，就会飞到天上或者掉入地底。</p>
<p>这种不稳定性太糟了，这个例子在这里的唯一原因是作为警示寓言，引领我们到更好的东西……</p>
<h3 id="追逐时间"><a href="#追逐时间" class="headerlink" title="追逐时间"></a>追逐时间</h3><p>游戏中渲染通常<em>不会</em>被动态时间间隔影响到。 由于渲染引擎表现的是时间上的一瞬间，它不会计算上次到现在过了多久。 它只是将当前事物渲染在所在的地方。</p>
<p>这或多或少是成立的。像动态模糊的东西会被时间间隔影响，但如果有一点延迟，玩家通常也不会注意到。</p>
<p>我们可以利用这点。 以固定的时间间隔<em>更新</em>游戏，因为这让所有事情变得简单，物理和AI也更加稳定。 但是我们允许灵活调整<em>渲染</em>的时刻，释放一些处理器时间。</p>
<p>它像这样运作：自上一次游戏循环过去了一定量的真实时间。 需要为游戏的“当前时间”模拟推进相同长度的时间，以追上玩家的时间。 我们使用一<em>系列</em>的<em>固定</em>时间步长。 代码大致如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> previous = <span class="title function_">getCurrentTime</span>();</span><br><span class="line"><span class="keyword">let</span> accumulator = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">    <span class="keyword">let</span> elapsed = current - previous;</span><br><span class="line">    previous = current;</span><br><span class="line">    accumulator += elapsed;</span><br><span class="line">    <span class="title function_">processInput</span>();</span><br><span class="line">    <span class="keyword">while</span> (accumulator &gt;= <span class="variable constant_">MS_PER_UPDATE</span>) &#123;</span><br><span class="line">        <span class="title function_">update</span>();</span><br><span class="line">        accumulator -= <span class="variable constant_">MS_PER_UPDATE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个部分。 在每帧的开始，根据过去了多少真实的时间，更新<code>lag</code>。 这个变量表明了游戏世界时钟比真实世界落后了多少，然后我们使用一个固定时间步长的内部循环进行追赶。 一旦我们追上真实时间，我们就渲染然后开始新一轮循环。 你可以将其画成这样：</p>
<img src="/2022/03/22/gameloop/game-loop-fixed.png" class="" title="修改后的流程图。处理输入 → 更新游戏 → 等待，然重回更新这步 → 渲染 → 回到开始。">

<p>注意这里的时间步长不是<em>视觉上的</em>帧率了。 <code>MS_PER_UPDATE</code>只是我们更新游戏的<em>间隔</em>。 这个间隔越短，就需要越多的处理次数来追上真实时间。 它越长，游戏抖动得越厉害。 理想上，你想要它足够短，通常快过60FPS，这样游戏在高速机器上会有高效的表现。</p>
<p>但是小心不要把它整得<em>太</em>短了。 你需要保证即使在最慢的机器上，这个时间步长也超过处理一次<code>update()</code>的时间。 否则，你的游戏就跟不上现实时间了。</p>
<p>所以，这就是为什么要好好规定MS_PER_UPDATE的原因了。我们也可以通过一些其他方法来消除这个问题，比如说增加内循环上限之类的。 游戏会变慢，但是比完全卡死要好。</p>
<p>幸运的是，我们给自己了一些喘息的空间。 技巧在于我们将<em>渲染拉出了更新循环</em>。 这释放了一大块CPU时间。 最终结果是游戏以固定时间步长<em>模拟</em>，该时间步长与硬件不相关。 只是使用低端硬件的玩家<em>看到的</em>内容会有抖动。</p>
<h3 id="剩下的时间"><a href="#剩下的时间" class="headerlink" title="剩下的时间"></a>剩下的时间</h3><p>但是剩下的时间怎么办呢？</p>
<p>要了解发生了什么，请考虑显示帧速率为 60fps 而物理以 50fps 运行的情况。没有很好的倍数，因此当余数“累积”到 dt 以上时，累加器会导致模拟在每帧主要执行一个物理步骤和偶尔执行两个物理步骤之间交替。</p>
<p>现在考虑大多数渲染帧将在累加器中留下一些小的剩余帧时间，因为它小于 dt，所以无法模拟。这意味着我们在与渲染时间略有不同的时间显示物理模拟的状态，导致屏幕上的物理模拟出现微妙但视觉上令人不快的停顿。</p>
<p>这是时间线：</p>
<img src="/2022/03/22/gameloop/game-loop-timeline.png" class="" title="一条时间线，上面是均匀分布的更新时刻和不均匀的渲染时刻。">

<p>就像你看到的那样，我们以紧凑固定的时间步长进行更新。 同时，我们在任何可能的时候渲染。 它比更新发生得要少，而且也不稳定。 两者都没问题。糟糕的是，我们不总能在正确的时间点渲染。 看看第三次渲染时间。它发生在两次更新之间。<img src="/2022/03/22/gameloop/game-loop-timeline-close.png" class="" title="时间线的一部分，渲染发生在两次更新之间。"></p>
<p>想象一颗子弹飞过屏幕。第一次更新时，它在左边。 第二次更新将它移到了右边。 这个游戏在两次更新之间的时间点渲染，所以玩家期望看到子弹在屏幕的中间。 而现在的实现中，它还在左边。这意味着看上去移动发生了卡顿。</p>
<p>方便的是，我们<em>实际</em>知道渲染时距离两次更新的时间：它被存储在<code>lag</code>中。 我们在<code>lag</code>比更新时间间隔小时，而不是<code>lag</code>是<em>零</em>时，跳出循环进行渲染。 <code>lag</code>的剩余量？那就是到下一帧的时间。</p>
<p>当我们要渲染时，我们将它传入：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(accumulator / <span class="variable constant_">MS_PER_UPDATE</span>);</span><br></pre></td></tr></table></figure>

<p>渲染器知道每个游戏对象<em>以及它当前的速度</em>。 假设子弹在屏幕左边20像素的地方，正在以400像素每帧的速度向右移动。 如果在两帧正中渲染，我们会给<code>render()</code>传0.5。 它绘制了半帧之前的图形，在220像素，啊哈，平滑的移动。</p>
<p>当然，也许这种推断是错误的。 在我们计算下一帧时，也许会发现子弹碰撞到另一障碍，或者减速，又或者别的什么。 我们只是在上一帧位置和我们<em>认为的</em>下一帧位置之间插值。 但只有在完成物理和AI更新后，我们才能知道真正的位置。</p>
<p>所以推断有猜测的成分，有时候结果是错误的。 但是，幸运地，这种修正通常不可感知。 最起码，比你不使用推断导致的卡顿更不明显。</p>
<h2 id="设计决策"><a href="#设计决策" class="headerlink" title="设计决策"></a>设计决策</h2><p>虽然这章我讲了很多，但是有更多的东西我没讲。 一旦你考虑显示刷新频率的同步，多线程，多GPU，真正的游戏循环会变得更加复杂。 即使在高层，这里还有一些问题需要你回答：</p>
<h3 id="选择平台还是自己的"><a href="#选择平台还是自己的" class="headerlink" title="选择平台还是自己的"></a>选择平台还是自己的</h3><p>这个选择通常是已经由平台决定的。 如果你在做浏览器中的游戏，很可能你<em>不能</em>编写自己的经典游戏循环。 浏览器本身的事件驱动机制阻碍了这一点。 类似地，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。</p>
<ul>
<li><strong>使用平台的事件循环：</strong><ul>
<li><em>简单</em>。你不必担心编写和优化自己的游戏核心循环。</li>
<li><em>平台友好。</em> 你不必明确地给平台一段时间让它处理它自己的事件，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处。</li>
<li><em>你失去了对时间的控制。</em> 平台会在它方便时调用代码。 如果这不如你想要的那样平滑或者频繁，太糟了。 更糟的是，大多数应用的事件循环并未为游戏设计，通常<em>是</em>又慢又卡顿。</li>
</ul>
</li>
<li><strong>使用游戏引擎的循环：</strong><ul>
<li><em>不必自己编写。</em> 编写游戏循环非常需要技巧。 由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。 稳固的游戏循环是使用现有引擎的原因之一。</li>
<li><em>不必自己编写。</em> 当然，硬币的另一面是，如果引擎无法满足你<em>真正的</em>需求，你也没法获得控制权。</li>
</ul>
</li>
<li><strong>自己写：</strong><ul>
<li><em>完全的控制。</em> 你可以做任何想做的事情。你可以为游戏的需求订制开发。</li>
<li><em>你需要与平台交互。</em> 应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。 如果你拥有应用的核心循环，平台就没有这些时间片了。 你得显式定期检查，保证框架没有挂起或者混乱。</li>
</ul>
</li>
</ul>
<h3 id="你如何控制游戏速度"><a href="#你如何控制游戏速度" class="headerlink" title="你如何控制游戏速度"></a>你如何控制游戏速度</h3><p>游戏循环有两个关键部分：不阻塞用户输入和自适应的帧时间步长。 输入部分很直观。关键在于你如何处理时间。 这里有数不尽的游戏可运行的平台， 每个游戏都需要在其中一些平台上运行。 如何适应平台的变化就是关键。</p>
<ul>
<li><p><strong>固定时间步长，没有同步：</strong></p>
<p>见我们第一个样例中的代码。你只需尽可能快地运行游戏。</p>
<ul>
<li><em>简单</em>。这是主要的（好吧，唯一的）好处。</li>
<li><em>游戏速度直接受到硬件和游戏复杂度影响。</em> 主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关。</li>
</ul>
</li>
<li><p><strong>固定时间步长，有同步：</strong></p>
<p>对复杂度控制的下一步是使用固定的时间间隔，但在循环的末尾增加同步点，保证游戏不会运行得过快。</p>
<ul>
<li><em>还是很简单。</em> 这比过于简单以至于不可行的例子只多了一行代码。 在多数游戏循环中，你可能<em>总</em>需要做一些同步。 你可能需要<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/double-buffer.html">双缓冲</a>图形并将缓冲块与更新显示的频率同步。</li>
<li><em>电量友好。</em> 这对移动游戏至关重要。你不想消耗不必要的电量。 通过简单地休眠几个毫秒而不是试图每帧塞入更多的处理，你就节约了电量。</li>
<li><em>游戏不会运行得太快。</em> 这解决了固定循环速度的一半问题。</li>
<li><em>游戏可能运行的太慢。</em> 如果花了太多时间更新和渲染一帧，播放也会减缓。 因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。 没法扔掉<em>渲染</em>帧来追上真实时间，游戏本身会变慢。</li>
</ul>
</li>
<li><p><strong>动态时间步长：</strong></p>
<p>我把这个方案放在这里作为问题的解决办法之一，附加警告：大多数我认识的游戏开发者反对它。 不过记住<em>为什么</em>反对它是很有价值的。</p>
<ul>
<li><em>能适应并调整，避免运行得太快或者太慢。</em> 如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上。</li>
<li><em>让游戏不确定而且不稳定。</em> 这是真正的问题，当然。在物理和网络部分使用动态时间步长会遇见更多的困难。</li>
</ul>
</li>
<li><p><strong>固定更新时间步长，动态渲染：</strong></p>
<p>在示例代码中提到的最后一个选项是最复杂的，但是也是最有适应性的。 它以固定时间步长更新，但是如果需要赶上玩家的时间，可以扔掉一些<em>渲染</em>帧。</p>
<ul>
<li><em>能适应并调整，避免运行得太快或者太慢。</em> 只要能实时<em>更新</em>，游戏状态就不会落后于真实时间。如果玩家用高端的机器，它会回以更平滑的游戏体验。</li>
<li><em>更复杂。</em> 主要负面问题是需要在实现中写更多东西。 你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘志杰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
